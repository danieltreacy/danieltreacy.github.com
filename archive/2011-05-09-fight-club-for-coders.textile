---
layout: post
title: Fight Club for Coders
---

<h2><a href="{{ page.url }}">{{ page.title }}</a></h2>

{{ page.date | date: "%b %d, %Y" }}

<p><img src="/images/funny-cat-engineer.jpg" />My project management lecturer had a habit of telling stories from "when I was a project manager". Bet you can tell they were riveting. One of said stories described the infamous LASCAD (London Ambulance Service Computer Aided Dispatch) fiasco of 1992 in which the LAS decided to upgrade their ambulance routing and dispatch system to be automated instead of pen and paper. For those of you who don't know, the new system was the ultimate definition of fail. As in, people died. Heavy stuff.

But that's the thing about mission-critical systems. Your N^2 loops that are leaking memory all over the shop aren't just going to bring down production, they're going to kill people. Software houses that develop these kind of systems all the time take QA and load testing more seriously than having a normal life, but since LAS decided to be a cheapskate and go for the McValue meal, the project landed in the incompetent hands of a firm that had never written a system so large before. Evidently, they had also never heard of SVT.</p>

Like most developers wanting to keep their bum in a seat and out of the welfare line, I take the quality of my code pretty seriously. I write tests, do code reviews, etc. Admittedly one of the benefits of working for a bank is that there's so many floodgates your code passes through before it even sniffs production, that even if you did forget to close that Hibernate connection, chances are it will get picked up somewhere between Cobertura and an overly zealous sysadmin. That said, in the legacy systems I've worked with I've sometimes stumbled across code so heinous it made me think the people who wrote it must have not cared at all about their career, or, more importantly, the future developers who would have to extend their pile of vomit. It's like pissing on the virtual floor. No one likes cleaning that up. It's easier to nuke the beast and start over. And probably cheaper. Problem is, big corporations are risk-averse towards technology. They would rather go for band-aids than real fixes simply to mitigate risk. But the reality is band-aids fall off. Maybe not this year, nor for the next 5-10 years, but one day they will fall off or impede some new development initiative that will require a thorough fix of the original problem anyway. 

Let me get to my point. As software engineers, we have become lazy. We have so many tools to help us do our job that it becomes mindless. Any monkey who has written something in PHP can sit at a desk and be writing production code for enterprise Java after 2 months, not because they're necessarily learning, but because they have 200 IntelliJ plugins that do most of the work for them. I know because that was me, until I actually started caring. I'm not saying it's wrong to learn on the job (aren't we all learning all the time anyway?) but the developer who takes an active interest in understanding the impact of their code and seeking to write better code as a continuous practice (not just fake-it-till-you-make-it), are doing a service to their employer, the industry, the users, and to themselves. 

So basically what I'm saying is that we need some sort of Fight Club for coders. People who came out of such a club wouldn't care about stupid things like impressing their colleagues with their l33t coding skillz, or rocking up to Rails conferences with their MacBook and latte to feel like they're a good developer. They would have a humility and respect for their their work because they've had to fight for their knowledge and experience, and wouldn't need to prove it to anyone. Most soldiers who have seen battle don't care about big guns. They care about preserving the value of life. Different paradigms.

Other engineering disciplines don't tolerate bullshit. Bridge falls down, you go to jail for negligence. Career over. So why not in software?

And don't say software never killed anyone.